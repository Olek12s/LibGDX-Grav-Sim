package io.gith;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Vector3;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class Main extends ApplicationAdapter {
    private int batchSize = 1;
    private static final int BATCH_MIN = 1;
    private static final int BATCH_MAX = 10_000_000;

    private List<Float> vertsList;
    private Mesh mesh;
    private ShaderProgram shader;
    private OrthographicCamera camera;
    private SpriteBatch uiBatch;
    private BitmapFont font;
    private float startTime;

    private static final int VERTEX_SIZE = 6; // 2 pos + 2 vel + 1 color + 1 birthTime

    private String vertexShader;
    private String fragmentShader;
    @Override
    public void create() {
        //Gdx.graphics.setVSync(false);
        createCamera();
        createShaders();

        vertsList = new ArrayList<>();
        addRandomPoints(10, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        rebuildMesh();

        uiBatch = new SpriteBatch();
        font = new BitmapFont();
        font.getData().setScale(1.2f);
        startTime = System.nanoTime() * 1e-9f;
    }

    private void createCamera() {
        camera = new OrthographicCamera();
        camera.setToOrtho(false, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        camera.update();
    }

    private void createShaders() {
        vertexShader =
            "attribute vec2 a_initPos;\n" +
                "attribute vec2 a_velocity;\n" +
                "attribute vec4 a_color;\n" +
                "attribute float a_birthTime;\n" +
                "uniform mat4 u_projTrans;\n" +
                "uniform float u_time;\n" +
                "uniform float u_width;\n" +
                "uniform float u_height;\n" +
                "varying vec4 v_color;\n" +
                "float bounce(float p, float limit) {\n" +
                "  float m = mod(p, limit * 2.0);\n" +
                "  return (m <= limit) ? m : (2.0 * limit - m);\n" +
                "}\n" +
                "void main() {\n" +
                "  float age = u_time - a_birthTime;\n" +
                "  vec2 raw = a_initPos + a_velocity * age;\n" +
                "  float x = bounce(raw.x, u_width);\n" +
                "  float y = bounce(raw.y, u_height);\n" +
                "  gl_Position = u_projTrans * vec4(x, y, 0.0, 1.0);\n" +
                "  gl_PointSize = 1.0;\n" +
                "  v_color = a_color;\n" +
                "}\n";

        fragmentShader =
            "#ifdef GL_ES\n" +
                "precision mediump float;\n" +
                "#endif\n" +
                "varying vec4 v_color;\n" +
                "void main() {\n" +
                "  gl_FragColor = v_color;\n" +
                "}\n";

        shader = new ShaderProgram(vertexShader, fragmentShader);
        if (!shader.isCompiled()) {
            throw new IllegalStateException("Shader compile error:\n" + shader.getLog());
        }
    }

    private void addRandomPoints(int count, int w, int h) {
        Random rnd = new Random();
        float birthTime = System.nanoTime() * 1e-9f - startTime;
        for (int i = 0; i < count; i++) {
            vertsList.add(rnd.nextFloat() * w);
            vertsList.add(rnd.nextFloat() * h);
            vertsList.add((rnd.nextFloat() - 0.5f) * 200f);
            vertsList.add((rnd.nextFloat() - 0.5f) * 200f);
            vertsList.add(com.badlogic.gdx.graphics.Color.toFloatBits(
                rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1f));
            vertsList.add(birthTime);
        }
    }

    private void addPointsAt(float x, float y, int count) {
        Random rnd = new Random();
        float birthTime = System.nanoTime() * 1e-9f - startTime;
        for (int i = 0; i < count; i++) {
            vertsList.add(x);
            vertsList.add(y);
            vertsList.add((rnd.nextFloat() - 0.5f) * 200f);
            vertsList.add((rnd.nextFloat() - 0.5f) * 200f);
            vertsList.add(com.badlogic.gdx.graphics.Color.toFloatBits(
                rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1f));
            vertsList.add(birthTime);
        }
    }

    private void rebuildMesh() {
        if (mesh != null) mesh.dispose();
        int n = vertsList.size() / VERTEX_SIZE;
        mesh = new Mesh(true, n, 0,
            new VertexAttribute(Usage.Position, 2, "a_initPos"),
            new VertexAttribute(Usage.Normal, 2, "a_velocity"),
            new VertexAttribute(Usage.ColorPacked, 4, "a_color"),
            new VertexAttribute(Usage.Generic, 1, "a_birthTime")
        );
        float[] arr = new float[vertsList.size()];
        for (int i = 0; i < arr.length; i++) arr[i] = vertsList.get(i);
        mesh.setVertices(arr);
    }

    @Override
    public void resize(int width, int height) {
        camera.setToOrtho(false, width, height);
        camera.update();
    }

    @Override
    public void render() {
        float time = System.nanoTime() * 1e-9f - startTime;

        if (Gdx.input.isKeyJustPressed(Input.Keys.PLUS) || Gdx.input.isKeyJustPressed(Input.Keys.EQUALS) || Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_ADD)) {
            batchSize = Math.min(batchSize * 10, BATCH_MAX);
        }
        if (Gdx.input.isKeyJustPressed(Input.Keys.MINUS) || Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_SUBTRACT)) {
            batchSize = Math.max(batchSize / 10, BATCH_MIN);
        }
        if (Gdx.input.isKeyJustPressed(Input.Keys.X)) {
            vertsList.clear();
            rebuildMesh();
        }

        if (Gdx.input.isButtonPressed(Input.Buttons.LEFT)) {
            Vector3 worldCoords = camera.unproject(new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0));
            addPointsAt(worldCoords.x, worldCoords.y, batchSize);
            rebuildMesh();
        }

        if (Gdx.input.isTouched(1)) { // scroll = button 2 in some configs
            Vector3 worldCoords = camera.unproject(new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0));
            addPointsAt(worldCoords.x, worldCoords.y, batchSize);
            rebuildMesh();
        }

        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        camera.update();
        shader.bind();
        shader.setUniformMatrix("u_projTrans", camera.combined);
        shader.setUniformf("u_time", time);
        shader.setUniformf("u_width", Gdx.graphics.getWidth());
        shader.setUniformf("u_height", Gdx.graphics.getHeight());

        mesh.render(shader, GL20.GL_POINTS);

        uiBatch.setProjectionMatrix(camera.combined); // ðŸŸ¢ dodane
        uiBatch.begin();
        String status = String.format("FPS: %d   Points: %d   /click: %d",
            Gdx.graphics.getFramesPerSecond(), vertsList.size() / VERTEX_SIZE, batchSize);
        font.draw(uiBatch, status, 10, camera.viewportHeight - 10); // ðŸŸ¢ Y zaleÅ¼ne od kamery
        uiBatch.end();
    }

    @Override
    public void dispose() {
        mesh.dispose();
        shader.dispose();
        uiBatch.dispose();
        font.dispose();
    }
}
