package io.gith;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class Main extends ApplicationAdapter {
    private OrthographicCamera camera;
    private SpriteBatch spriteBatch;
    private BitmapFont font;
    private Texture circleTexture;

    private class Particle {
        Vector2 position;
        Vector2 velocity;
        float radius;
        Color color;

        Particle(float x, float y, float vx, float vy, float radius, Color color) {
            this.position = new Vector2(x, y);
            this.velocity = new Vector2(vx, vy);
            this.radius = radius;
            this.color = color;
        }
    }

    private List<Particle> particles;
    private Random rnd;
    private int batchSize = 10;

    @Override
    public void create() {
        camera = new OrthographicCamera();
        camera.setToOrtho(false, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

        spriteBatch = new SpriteBatch();
        font = new BitmapFont();
        font.setColor(Color.WHITE);

        particles = new ArrayList<>();
        rnd = new Random();

        createCircleTexture();

        addParticles(batchSize);
    }

    private void createCircleTexture() {
        int size = 64;
        Pixmap pixmap = new Pixmap(size, size, Pixmap.Format.RGBA8888);
        pixmap.setBlending(Pixmap.Blending.None);
        pixmap.setColor(1, 1, 1, 1);
        pixmap.fillCircle(size / 2, size / 2, size / 2);
        circleTexture = new Texture(pixmap);
        pixmap.dispose();
    }

    private void addParticles(int count) {
        for (int i = 0; i < count; i++) {
            float x = rnd.nextFloat() * Gdx.graphics.getWidth();
            float y = rnd.nextFloat() * Gdx.graphics.getHeight();
            float vx = (rnd.nextFloat() - 0.5f) * 200f;
            float vy = (rnd.nextFloat() - 0.5f) * 200f;
            float radius = 1f + rnd.nextFloat() * 9f;
            Color color = new Color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1f);
            particles.add(new Particle(x, y, vx, vy, radius, color));
        }
    }

    private void addParticlesAt(float x, float y, int count) {
        for (int i = 0; i < count; i++) {
            float vx = (rnd.nextFloat() - 0.5f) * 200f;
            float vy = (rnd.nextFloat() - 0.5f) * 200f;
            float radius = 1f + rnd.nextFloat() * 9f;
            Color color = new Color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1f);
            particles.add(new Particle(x, y, vx, vy, radius, color));
        }
    }

    @Override
    public void resize(int width, int height) {
        camera.setToOrtho(false, width, height);
    }

    @Override
    public void render() {
        float delta = Gdx.graphics.getDeltaTime();

        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        camera.update();
        spriteBatch.setProjectionMatrix(camera.combined);

        if (Gdx.input.isButtonPressed(Input.Buttons.LEFT)) {
            Vector3 worldCoords = camera.unproject(new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0));
            addParticlesAt(worldCoords.x, worldCoords.y, batchSize);
        }

        // Aktualizacja pozycji
        for (Particle p : particles) {
            p.position.x += p.velocity.x * delta;
            p.position.y += p.velocity.y * delta;

            if (p.position.x < p.radius) {
                p.position.x = p.radius;
                p.velocity.x = -p.velocity.x;
            } else if (p.position.x > Gdx.graphics.getWidth() - p.radius) {
                p.position.x = Gdx.graphics.getWidth() - p.radius;
                p.velocity.x = -p.velocity.x;
            }

            if (p.position.y < p.radius) {
                p.position.y = p.radius;
                p.velocity.y = -p.velocity.y;
            } else if (p.position.y > Gdx.graphics.getHeight() - p.radius) {
                p.position.y = Gdx.graphics.getHeight() - p.radius;
                p.velocity.y = -p.velocity.y;
            }
        }

        // Rysowanie sprite’ów (szybko!)
        spriteBatch.begin();
        for (Particle p : particles) {
            spriteBatch.setColor(p.color);
            float size = p.radius * 2;
            spriteBatch.draw(circleTexture, p.position.x - p.radius, p.position.y - p.radius, size, size);
        }

        // Tekst
        spriteBatch.setColor(Color.WHITE);
        font.draw(spriteBatch, "FPS: " + Gdx.graphics.getFramesPerSecond(), 10, Gdx.graphics.getHeight() - 10);
        font.draw(spriteBatch, "Particles: " + particles.size(), 10, Gdx.graphics.getHeight() - 30);
        font.draw(spriteBatch, "Particles per click: " + batchSize, 10, Gdx.graphics.getHeight() - 50);
        spriteBatch.end();

        if (Gdx.input.isKeyJustPressed(Input.Keys.PLUS) ||
            Gdx.input.isKeyJustPressed(Input.Keys.EQUALS) ||
            Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_ADD)) {
            batchSize = Math.min(batchSize * 2, 1000);
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.MINUS) ||
            Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_SUBTRACT)) {
            batchSize = Math.max(batchSize / 2, 1);
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.X)) {
            particles.clear();
        }
    }

    @Override
    public void dispose() {
        spriteBatch.dispose();
        font.dispose();
        circleTexture.dispose();
    }
}
